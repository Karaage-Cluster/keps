KEP 5: Karaage 4
================

:Created: 2015-03-17
:Author: Brian May
:Status: Draft

.. contents:: :local:

.. sectnum::

Overview
--------
This document outlines the path for the future of Karaage, including Karaage 4.

This doesn't isn't an official V3 Alliance document and doesn't reflect V3's
official position with Karaage. It is draft status only, and the contents may
change without notice.

Contributions are welcome.


Background
----------
Karaage is a cluster management system initially developed by VPAC (now V3
Alliance), and is in use by numerous organisations around Australia. As a major
piece of infrastructure software, it has been unfortunately, lagging with
respect to innovation and development of new features. Currently the majority
of code development is tied to one individual, with minimal input from other
stakeholders.

V3 Alliance has been installing Karaage at clusters setup for V3's clients.
Unfortunately these sites often get deployed without any sort of maintenance
plan. This results in clients repeatedly encountering known bugs that
have been fixed in the latest Karaage version, which in turn gives
Karaage a bad look.

One of these sites was VLSCI. VLSCI started encountering limitations of
Karaage.  As a result, they employed Common Code to deliver a set of features.
Common Code produced a new schema for Karaage, however were unable to produce
the new views to take advantage of this new schema in the time allowed.

A related issue that has risen is the need to pay for Karaage development.
Development is an expensive process, and there is no funding model to
continue the development of Karaage.


Current Progress
----------------
There were a number of issues with the Common Code repository. These changes
were cleaned up into a set of well formed patches, and these applied against
Karaage 3 to create the new official Karaage4 branch.

Major Changes adapted from Common Code and merged into Karaage4 branch:

* Make institute/project/software groups unique. Every group can only be used
  by one institute, by one project, and by one piece of software.
* Add CareerLevel table. Every person can has a career level.
* Add ProjectLevel table. Every person has a project level for every project.
* New method to set group members.
* New ProjectMembership table. Changes to membership get written to the Group
  table. Changes to the Group table will not get synced to this table.
* Projects hierarchy.
* Add GrantSchemes table.
* Add resources and resource pools.
* Add Grants and Allocations.
* Add aggregated usage table.
* Add audit logs to more tables (except Person???)
* Add allocation_mode to projects.
* Make group references OneToOneFields.

Changes not yet merged into Karaage4 branch and need further discussion and/or
further work:

* PublicNotes
* Changes to groups.
* Changes to configuration.

Karaage 4 requires Django 1.7, which means Django south migrations will not
work any more. This means that installations must upgrade to Karaage 3 first
before upgrading to Karaage 4.

Rationale
---------
This section documents the changes that have been made or proposed for Karaage 4 with the rationale as to why the changes have been considered a good idea.

Use of Audit Log
~~~~~~~~~~~~~~~~
The audit log plugin creates a duplicate database table for every model that records historic information for the models.
It's use may mean that adhoc methods used in Karaage to record historic information may not be required anymore, and should
be refactored.

CareerLevel model
~~~~~~~~~~~~~~~~~

.. code-block:: python

    @python_2_unicode_compatible
    class CareerLevel(models.Model):
        level = models.CharField(max_length=255)

        audit_log = AuditLog()

        def __str__(self):
            return self.level

        class Meta:
            ordering = ['level']

    @python_2_unicode_compatible
    class Person(AbstractBaseUser):
        career_level = models.ForeignKey(
            'karaage.CareerLevel',
            blank=False,  # don't allow saving without filling this in...
            null=True,  # ...but do allow legacy records in DB to be NULL
        )

        ...

The ``CareerLevel`` table is used to specify the job title of the Person.

ProjectLevel model
~~~~~~~~~~~~~~~~~~

.. code-block:: python

    @python_2_unicode_compatible
    class ProjectLevel(models.Model):
        level = models.CharField(max_length=255)

        audit_log = AuditLog()

        def __str__(self):
            return self.level

        class Meta:
            ordering = ['level']

The ``ProjectLevel`` table is required for ???.

ProjectMembership model
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    @python_2_unicode_compatible
    class ProjectMembership(models.Model):

        """
        Mapping between projects and people with details about their project role.

        TODO: Automatic update project membership using signals from Group.members,
        using defaults defined below.
        """

        person = models.ForeignKey('karaage.Person')
        project = models.ForeignKey('karaage.Project')
        project_level = models.ForeignKey(
            'karaage.ProjectLevel',
            blank=False,  # don't allow saving without filling this in...
            null=True,  # ...but do allow legacy records in DB to be NULL
        )
        is_project_supervisor = models.BooleanField(default=False)
        is_project_leader = models.BooleanField(default=False)
        is_default_project = models.BooleanField(default=False)
        is_primary_contact = models.BooleanField(default=False)

        def __str__(self):
            return '{} @ {}'.format(self.person, self.project)

     @python_2_unicode_compatible
     class Person(AbstractBaseUser):
        projects = models.ManyToManyField(
            'karaage.Project',
            through='karage.ProjectMembership',
            through_fields=('person', 'project'),
        )

        ...



The ``ProjectMembership`` table is required to keep track of additional information
for every ``Person`` in a particular ``Project``, such as the ``ProjectLevel`` and the
person's role inside the project. A ``Person`` can be a supervisor or leader of a
``Project``. A ``Person`` can nominate a ``Project`` as a default project. A ``Person`` can
be designated the primary contact for the ``Project``.

Project model
~~~~~~~~~~~~~

.. code-block:: python

    class Project(MPTTModel):

        ...

        # MPTT fields
        parent = TreeForeignKey(
            'self', null=True, blank=True, related_name='children')
        lft = models.PositiveIntegerField(db_index=True, editable=False)
        rght = models.PositiveIntegerField(db_index=True, editable=False)
        tree_id = models.PositiveIntegerField(db_index=True, editable=False)
        level = models.PositiveIntegerField(db_index=True, editable=False)

        ...

The ``Project`` hierarchy, using MPTT, replaces the current ``Institute`` model. The top level
``Projects`` would be the ``Institutes``, and the descendants the ``Projects` belonging
to these ``Institutes``. This means usage can be assigned to a ``Project``, and this
will work even if the ``Project`` is an ``Institute``.

Schemes model
~~~~~~~~~~~~~

.. code-block:: python

    class Scheme(models.Model):
        name = models.CharField(max_length=200, unique=True)
        description = models.CharField(max_length=200, null=False, blank=True)
        opened = models.DateField()
        closed = models.DateField(null=True, blank=True)

        objects = models.Manager()
        active = ActiveSchemeManager()
        deleted = DeletedSchemeManager()

        audit_log = AuditLog()

        def __str__(self):
            return self.name

        class Meta:
            ordering = ['name']

The ``Scheme`` defines a source of grants over a specific period of time.

Resource and ResourcePool models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    class ResourcePool(models.Model):
        name = models.CharField(max_length=255, unique=True)

        audit_log = AuditLog()

        def __str__(self):
            return self.name

        class Meta:
            ordering = ['name']


    class Resource(models.Model):

        class ResourceType:
            SLURM_CPU = 'slurm_cpu'
            SLURM_MEM = 'slurm_mem'
            GPFS = 'gpfs'

        RESOURCE_TYPE_CHOICES = [
            (ResourceType.SLURM_CPU, 'Slurm (CPU)'),
            (ResourceType.SLURM_MEM, 'Slurm (MEM)'),
            (ResourceType.GPFS, 'GPFS'),
        ]

        machine = models.ForeignKey('karaage.Machine')
        resource_pool = models.ForeignKey('karaage.ResourcePool')
        scaling_factor = models.FloatField()
        resource_type = models.CharField(
            max_length=255,
            choices=RESOURCE_TYPE_CHOICES,
        )
        quantity = models.BigIntegerField()

        audit_log = AuditLog()

        def __str__(self):
            return '%s / %s @ %s' % (
                self.machine,
                self.resource_type,
                self.resource_pool
            )

        class Meta:
           ordering = ['resource_type']


Karaage 4 supports tracking information other then CPU hours. This is done
by defining a ``ResourcePool`` for every metric we want to track. The ``Resource``
model defines how we track this metric for a given ``Machine``.

Grant, AllocationPool, Allocation, and AllocationPeriod models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    class Grant(models.Model):
        project = models.ForeignKey('karaage.Project')
        scheme = models.ForeignKey('karaage.Scheme')
        description = models.CharField(max_length=255)
        date = models.DateField()
        begins = models.DateField()
        expires = models.DateField()

        audit_log = AuditLog()

        def __str__(self):
            return self.description

        class Meta:
            ordering = [
                '-expires',
                '-project__end_date',
                'project__name',
                'description',
            ]

    class AllocationPool(models.Model):

        """
        Grouping of resources allocated to a grant (project).

        AllocationMode='capped' is not supported yet, until a demonstratted need is
        shown (and optionally that we can use an array of foreign key to relate
        from Usage to AllocationPool to avoid the M2M join table).

        TODO: User documentation of the allocation behaviour with concrete
        examples.
        """

        project = models.ForeignKey('karaage.Project')
        period = models.ForeignKey('karaage.AllocationPeriod')
        resource_pool = models.ForeignKey('karaage.ResourcePool')

        @cached_property
        def allocated(self):
            return self.allocation_set.aggregate(
                a=models.Sum('quantity'))['a'] or 0.0

        @cached_property
        def used(self):
            return self.usage_set.aggregate(u=models.Sum('used'))['u'] or 0.0

        @cached_property
        def raw_used(self):
            return self.usage_set.aggregate(r=models.Sum('raw_used'))['r'] or 0.0

        @cached_property
        def used_percent(self):
            if self.allocated == 0.0:
                return None
            return 100.0 * self.used / self.allocated

        @cached_property
        def remaining(self):
            return self.allocated - self.used

        objects = AllocationPoolQuerySet.as_manager()
        audit_log = AuditLog()

        def __str__(self):
            return 'Project: %s' % self.project.name

        class Meta:
            ordering = [
                '-period__end',
                '-project__end_date',
                'project__name',
            ]

    class Allocation(models.Model):
        description = models.CharField(max_length=100)
        grant = models.ForeignKey('karaage.Grant')
        allocation_pool = models.ForeignKey('karaage.AllocationPool')
        quantity = models.FloatField()

        audit_log = AuditLog()

        def __str__(self):
            return self.description

        class Meta:
            ordering = [
                'allocation_pool',
            ]

    class AllocationPeriod(models.Model):
        name = models.CharField(max_length=255)
        start = models.DateTimeField()
        end = models.DateTimeField()

        audit_log = AuditLog()

        def __str__(self):
            return self.name

        class Meta:
            ordering = [
                '-end',
                'name',
            ]


The ``Grant`` defines an allowance of ``Resources`` for a specific ``Project`` for a specific
duration, but does not define what those resources are. The ``AllocationPool`` adds
the resource pool used by the project over a specific time period (``AllocationPeriod``), and
the ``Allocation`` defines what the allowance is for this resource pool.

Usage model
~~~~~~~~~~~
The aggregated ``Usage`` model is designed to speed up access to usage information
by aggregating it into one table, as well as make it independent of the
resource being monitored.


Example
-------
At a fictional site, we have the following machines:

* ``MachineCategory`` { name: default }
* ``Machine`` { name: brecca, machine_category: default }
* ``Machine`` { name: tango, machine_category: default }

We define the following projects:

* ``Project`` { pid: InstituteA }
* ``Project`` { pid: InstituteB }
* ``Project`` { pid: ProjectA, parent: InstituteA }
* ``Project`` { pid: ProjectB, parent: InstituteA }
* ``Project`` { pid: ProjectC, parent: InstituteC }
* ``Project`` { pid: ProjectD, parent: ProjectC }

This shows how the project hierarchy would work.

We want to track disk space and CPU hours, so we define two resource pools.

* ``ResourcePool`` { name: Disk Space }
* ``ResourcePool`` { name: CPU Hours }

We define the following resources:

* ``Resource`` { machine: brecca, resource_pool: Disk Space, quantity=??? }
* ``Resource`` { machine: brecca, resource_pool: CPU Hours, quantity=??? }
* ``Resource`` { machine: tango, resource_pool: Disk Space, quantity=??? }
* ``Resource`` { machine: tango, resource_pool: CPU Hours, quantity=??? }

For this fictional site, ET is the major sponsor, So we define the following
scheme:

* ``Scheme`` { name: ET, opened: 2100-01-01, closed=None }

ET has been generous enough to give Grants to various projects:

* ``Grant`` { id: 1, project: ProjectA, scheme: ET, begins: 2100-01-01, expires=2100-12-31 }
* ``Grant`` { id: 2, project: ProjectD, scheme: ET, begins: 2100-01-01, expires=2100-12-31 }

At this stage we haven't defined the resources allocated for this project. Lets
do that:

* ``AllocationPool`` { id: 1, project: ProjectA, period: 2100, pool: Disk Space }
* ``Allocation`` { grant: 1, allocation_pool: 1, quantity: 100KB }
* ``Allocation`` { grant: 1, allocation_pool: 1, quantity: 500KB }
* ``AllocationPool`` { id: 2, project: ProjectA, period: 2100, pool: CPU Hours }
* ``Allocation`` { grant: 1, allocation_pool: 2, quantity: 10 }
* ``Allocation`` { grant: 1, allocation_pool: 2, quantity: 50 }

Note that the two resource pools have different properties - CPU hours is
accumulative and each new entry will add to the previous total. Where as with
disk space, we are more concerned about the maximum about of disk space used
at any one time. The distinction between these two formats has not been made
in the current schema.

PublicNotes model
~~~~~~~~~~~~~~~~~

.. code-block::

    @python_2_unicode_compatible
    class PublicNotes(models.Model):
        note = models.TextField()
        when = models.DateTimeField()
        content_type = models.ForeignKey(ContentType)
        object_id = models.PositiveIntegerField()
        content_object = GenericForeignKey('content_type', 'object_id')
        person = models.ForeignKey('karaage.Person')

        def __str__(self):
            return self.note

        class Meta:
            ordering = ['-when']

This needs a use case.

Future work
-----------
Future technical changes required:

* Some models don't use ``python_2_unicode_compatible``, this probably should be fixed.
* Investigate proposed changes to groups, see if this can be improved on.
* Import usage information into aggregated table.
* Migration to put usage information in new aggregated table.
* Rewrite usage plugin. New plugin should be able to graph data from multiple
  sources, e.g. CPU time and disk space.

Funding issues:

* It has been suggested that a way forward would be to make Karaage
  proprietary. However Karaage has always been Open Source software and has had
  contributions from different sources. Changing this would be infeasible.

* Another option that has been suggested is to develop proprietary add on
  plugins for Karaage. This would limit the exposure of these plugins however,
  and likely to severely limit the user base for the plugin.

* V3 Alliance should be selling support contracts with every Karaage
  installation deployed. We should be ensuring that all Karaage installations
  are up-to-date with the latest stable release of Karaage, with latest
  security updates.

* Furthermore V3 Alliance should supply feature requests in exchange for
  funding for the development work required.
